*****************************************************************************
                               Reflection
                             Workshop - #4
Full Name  : Jiaheng Wang
Student ID#: 180562217

Authenticity Declaration:
I declare this submission is the result of my own work and has not been
shared with any other student or 3rd party content provider. This submitted
piece of work is entirely of my own creation.
*****************************************************************************
1. When we need to perform different tasks in different paths, we need to use selection constructs to discuss different situations. For example, in Workshop4 Part2, first of all, we need to ensure users input the number of products >= 0, so we should use selection constructs alternative path: if the user input the number < 0, there will be an ERROR: Value must be 0 or more; in the else situation (number >= 0), we can do the next instruction. If we do not do the selection, when users input a negative number, it is meaningless, and we cannot execute the next step correctly. Secondly, when we help customers pick up the products, we should ensure the product number is not zero. If the customer does not need some product, we can skip this kind of product and only execute the necessary procedure. Thirdly, we need to compare the number of products we picked and the quantity of product the customer need. If the quantity is less than what the customer needs, we should pick some more. If the quantity is more than what the customer needs, we should pick the correct number again. Only if the number we picked is equal to the number of the customer needed, we will finish this product pick and pick another product next.

2. Nested constructs is enclosing one logic construct within another construct. In part 2 of Workshop 4, I used nested selection to sort whether the quantity we pick up is positive or not first. If the quantity is not positive, we will report an error. If the quantity is positive, we need to classify the relationship between the quantity already picked up and the quantity of the customer's need. If the number we picked up is less than the number of the customer need, we need to pick up more until it is enough for the demand. We enclosed the relationship between the number we picked up and the customer need into another selection construct whether the quantity we pick up is positive or not. Also, I used nested iterations. Firstly, I create a do-while loop to pick up every product once according to the customer's demand. However, it can only execute once. If the customer forgets to select some products, it cannot add some anymore. Therefore, we need to create another do-while loop enclosing the iteration, so that customers can add some products after picking again and again until they input "0" to finish picking. 

3. My favourite iteration construct is for loop because it can be used in many situations, especially when we know the iteration times. In addition, it is clear to find the initialization, test condition and change so that we can correct them easily. While loop will execute the sequence again and again as long as the test condition is true. It usually applies to the situation that we do not know the iteration times, but we want to judge if something qualifies some conditions. It can help us to select or filter different types. Do-while loop can execute the sequence first and then judge the condition true or false. It is similar to while loop but it can at least execute once while while loop will not execute if the condition is false. Moreover, if we need to obtain some data from users, such as scanf(), in the sequence to determine test condition, we can only use do while because we need to execute scanf() first and then judge the condition. For example, in part 2, we need to obtain the product's number from users' input to judge when it meets the condition. In this situation, we had better use do while loop. Further, in this workshop, while loop and do while loop are better than for loop because we do not know the iteration times but we need to meet the condition of picking enough products.
